# Phase 1 — Foundation: Implementation Plan

**Goal**: Scaffold the project and build the entire calculation engine with tests. At the end of Phase 1, we have zero UI — but every number the app will ever produce is correct and proven.

---

## Step 1: Scaffold Project

### Commands
```bash
npm create vite@latest . -- --template react-ts
npm install
npm install -D tailwindcss @tailwindcss/vite
npm install lucide-react @headlessui/react
npm install -D vitest
```

### Files Created
- `package.json` — generated by Vite
- `tsconfig.json` — generated by Vite
- `vite.config.ts` — add Tailwind plugin
- `src/index.css` — Tailwind directives
- `src/main.tsx` — default entry (leave as-is for now)
- `src/App.tsx` — placeholder (will be built in Phase 2)

### Configuration

**`vite.config.ts`** — add Tailwind:
```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [react(), tailwindcss()],
})
```

**`src/index.css`** — Tailwind v4 import:
```css
@import "tailwindcss";
```

**`tsconfig.json`** — ensure strict mode:
```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true
  }
}
```

**`vitest`** — add test script to `package.json`:
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest"
  }
}
```

### Best Practices
- Use `strict: true` from the start — catching nulls and type errors early in the calc engine saves debugging later.
- `noUncheckedIndexedAccess: true` — forces us to handle cases where array/record lookups could be undefined. Critical for a calculator where wrong index access = wrong numbers.

### Validation
- [x] `npm run dev` starts without errors, shows default Vite React page
- [x] `npm run build` completes with zero warnings
- [x] `npm test` runs (no tests yet, but Vitest initializes)
- [x] Tailwind is working: add `className="text-red-500"` to App.tsx, verify red text renders

---

## Step 2: Define Types — `src/lib/types.ts`

### File Created
`src/lib/types.ts`

### Content

```ts
// --- Domain Constants ---

export type CabinetType = '16:9' | '1:1'

export type Unit = 'mm' | 'm' | 'ft' | 'in'

export type Param = 'aspectRatio' | 'height' | 'width' | 'diagonal'

// --- Cabinet ---

export type Cabinet = {
  readonly width: number   // mm
  readonly height: number  // mm
}

// --- Aspect Ratio Preset ---

export type AspectRatioPreset = {
  readonly label: string   // e.g. "16:9"
  readonly value: number   // e.g. 1.7778
}

// --- Calculation Input ---

export type CalcInput =
  | { combo: 'ar_height';       ar: number; height: number }
  | { combo: 'ar_width';        ar: number; width: number }
  | { combo: 'ar_diagonal';     ar: number; diagonal: number }
  | { combo: 'height_width';    height: number; width: number }
  | { combo: 'height_diagonal'; height: number; diagonal: number }
  | { combo: 'width_diagonal';  width: number; diagonal: number }

// --- Calculation Output ---

export type Config = {
  cabinetType: CabinetType
  rows: number
  cols: number
  totalCabinets: number
  widthMM: number
  heightMM: number
  diagonalMM: number
  aspectRatio: number
}

// --- Persistence ---

export type SavedSelection = {
  id: string
  cabinetType: CabinetType
  rows: number
  cols: number
  widthMM: number
  heightMM: number
  diagonalMM: number
  aspectRatio: number
  totalCabinets: number
  inputParams: {
    combo: string
    values: Record<string, number>
    unit: Unit
  }
  savedAt: number
}

export type QuoteRequest = {
  id: string
  selectionId: string | null
  name: string
  contactMethod: 'email' | 'phone'
  contactValue: string
  submittedAt: number
}
```

### Best Practices
- All dimension fields suffixed with `MM` to make the unit unambiguous at the type level.
- `CalcInput` is a discriminated union on `combo` — the calc engine can exhaustively switch on it. TypeScript will error if we miss a case.
- `Cabinet` and `AspectRatioPreset` are `readonly` — config values should never be mutated.
- No `any`, no `as` casts. If a type doesn't fit, fix the type.

### Validation
- [x] File compiles with zero errors: `npx tsc --noEmit`
- [x] Every type is exported and importable from another file

---

## Step 3: Configuration Constants — `src/lib/config.ts`

### File Created
`src/lib/config.ts`

### Content

```ts
import type { Cabinet, CabinetType, AspectRatioPreset, Unit } from './types'

export const CABINETS: Record<CabinetType, Cabinet> = {
  '16:9': { width: 600, height: 337.5 },
  '1:1':  { width: 500, height: 500 },
}

export const ASPECT_RATIOS: AspectRatioPreset[] = [
  { label: '16:9',  value: 16 / 9 },
  { label: '16:10', value: 16 / 10 },
  { label: '4:3',   value: 4 / 3 },
  { label: '1:1',   value: 1 },
  { label: '21:9',  value: 21 / 9 },
  { label: '32:9',  value: 32 / 9 },
]

export const MM_PER_UNIT: Record<Unit, number> = {
  mm: 1,
  m:  1000,
  ft: 304.8,
  in: 25.4,
}

export const CABINET_TYPES: CabinetType[] = Object.keys(CABINETS) as CabinetType[]
```

### Best Practices
- AR values computed from fractions (`16 / 9`) not hardcoded decimals — avoids transcription errors.
- `CABINET_TYPES` array derived from `CABINETS` object — single source of truth. Adding a new cabinet type in one place propagates everywhere.
- All values are plain constants, no logic. This file is a data sheet.

### Validation
- [x] File compiles with zero errors
- [x] `CABINETS['16:9'].width === 600`
- [x] `ASPECT_RATIOS[0].value` is approximately `1.7778` (16/9)
- [x] `CABINET_TYPES.length === 2`

---

## Step 4: Unit Conversion — `src/lib/units.ts`

### File Created
`src/lib/units.ts`

### Content

```ts
import type { Unit } from './types'
import { MM_PER_UNIT } from './config'

export function toMM(value: number, unit: Unit): number {
  return value * MM_PER_UNIT[unit]
}

export function fromMM(mm: number, unit: Unit): number {
  return mm / MM_PER_UNIT[unit]
}
```

### Best Practices
- Two functions, no state, no side effects. Pure in, pure out.
- No rounding here — rounding is a display concern, not a conversion concern.

### Validation
- [x] File compiles
- [x] Tested in Step 5

---

## Step 5: Unit Conversion Tests — `src/lib/units.test.ts`

### File Created
`src/lib/units.test.ts`

### Test Cases

```ts
import { describe, it, expect } from 'vitest'
import { toMM, fromMM } from './units'

describe('toMM', () => {
  it('mm is identity', () => {
    expect(toMM(100, 'mm')).toBe(100)
  })

  it('meters to mm', () => {
    expect(toMM(1, 'm')).toBe(1000)
    expect(toMM(2.5, 'm')).toBe(2500)
  })

  it('feet to mm', () => {
    expect(toMM(1, 'ft')).toBeCloseTo(304.8)
  })

  it('inches to mm', () => {
    expect(toMM(1, 'in')).toBeCloseTo(25.4)
    expect(toMM(100, 'in')).toBeCloseTo(2540)
  })
})

describe('fromMM', () => {
  it('mm is identity', () => {
    expect(fromMM(100, 'mm')).toBe(100)
  })

  it('mm to inches', () => {
    expect(fromMM(2540, 'in')).toBeCloseTo(100)
    expect(fromMM(25.4, 'in')).toBeCloseTo(1)
  })

  it('mm to meters', () => {
    expect(fromMM(1000, 'm')).toBe(1)
  })

  it('mm to feet', () => {
    expect(fromMM(304.8, 'ft')).toBeCloseTo(1)
  })

  it('round-trip: toMM then fromMM returns original', () => {
    const units: Array<'mm' | 'm' | 'ft' | 'in'> = ['mm', 'm', 'ft', 'in']
    for (const unit of units) {
      expect(fromMM(toMM(42.5, unit), unit)).toBeCloseTo(42.5)
    }
  })
})
```

### Best Practices
- `toBeCloseTo` for floating point comparisons — never `toBe` for non-integer results.
- Round-trip test catches asymmetric conversion bugs.
- Test all 4 units, not just one.

### Validation
- [x] `npm test` — all unit conversion tests pass
- [x] 0 failures, 0 skipped

---

## Step 6: Calculation Engine — `src/lib/calculate.ts`

### File Created
`src/lib/calculate.ts`

This is the most critical file. It implements all 6 parameter combinations from PRD section 8.2.

### Content Structure

```ts
import type { CalcInput, Config, Cabinet, CabinetType } from './types'
import { CABINETS, CABINET_TYPES } from './config'

// --- Helper: build a Config from (rows, cols) ---

function buildConfig(
  rows: number,
  cols: number,
  cabinetType: CabinetType,
  cabinet: Cabinet
): Config {
  const widthMM = cols * cabinet.width
  const heightMM = rows * cabinet.height
  return {
    cabinetType,
    rows,
    cols,
    totalCabinets: rows * cols,
    widthMM,
    heightMM,
    diagonalMM: Math.sqrt(widthMM ** 2 + heightMM ** 2),
    aspectRatio: widthMM / heightMM,
  }
}

// --- Helper: lower/upper for a single axis ---

function floorCeil(exact: number): [number, number] {
  const lower = Math.max(Math.floor(exact), 1)
  let upper = Math.ceil(exact)
  if (upper <= lower) upper = lower + 1
  return [lower, upper]
}

// --- Category A: AR + one dimension ---

function calcARHeight(
  targetAR: number,
  targetH: number,
  cabinetType: CabinetType,
  cab: Cabinet
): [Config, Config] {
  const [rowsLower, rowsUpper] = floorCeil(targetH / cab.height)

  function colsForRows(rows: number): number {
    const actualH = rows * cab.height
    const desiredW = actualH * targetAR
    return Math.max(Math.round(desiredW / cab.width), 1)
  }

  return [
    buildConfig(rowsLower, colsForRows(rowsLower), cabinetType, cab),
    buildConfig(rowsUpper, colsForRows(rowsUpper), cabinetType, cab),
  ]
}

function calcARWidth(
  targetAR: number,
  targetW: number,
  cabinetType: CabinetType,
  cab: Cabinet
): [Config, Config] {
  const [colsLower, colsUpper] = floorCeil(targetW / cab.width)

  function rowsForCols(cols: number): number {
    const actualW = cols * cab.width
    const desiredH = actualW / targetAR
    return Math.max(Math.round(desiredH / cab.height), 1)
  }

  return [
    buildConfig(rowsForCols(colsLower), colsLower, cabinetType, cab),
    buildConfig(rowsForCols(colsUpper), colsUpper, cabinetType, cab),
  ]
}

function calcARDiagonal(
  targetAR: number,
  targetD: number,
  cabinetType: CabinetType,
  cab: Cabinet
): [Config, Config] {
  const targetH = targetD / Math.sqrt(1 + targetAR ** 2)
  return calcARHeight(targetAR, targetH, cabinetType, cab)
}

// --- Category B: two physical dimensions ---

function calcHeightWidth(
  targetH: number,
  targetW: number,
  cabinetType: CabinetType,
  cab: Cabinet
): [Config, Config] {
  const [rowsLower, rowsUpper] = floorCeil(targetH / cab.height)
  const [colsLower, colsUpper] = floorCeil(targetW / cab.width)

  return [
    buildConfig(rowsLower, colsLower, cabinetType, cab),
    buildConfig(rowsUpper, colsUpper, cabinetType, cab),
  ]
}

function calcHeightDiagonal(
  targetH: number,
  targetD: number,
  cabinetType: CabinetType,
  cab: Cabinet
): [Config, Config] {
  const targetW = Math.sqrt(targetD ** 2 - targetH ** 2)
  return calcHeightWidth(targetH, targetW, cabinetType, cab)
}

function calcWidthDiagonal(
  targetW: number,
  targetD: number,
  cabinetType: CabinetType,
  cab: Cabinet
): [Config, Config] {
  const targetH = Math.sqrt(targetD ** 2 - targetW ** 2)
  return calcHeightWidth(targetH, targetW, cabinetType, cab)
}

// --- Router: dispatch to correct combo ---

function calculateForCabinet(
  input: CalcInput,
  cabinetType: CabinetType,
  cab: Cabinet
): [Config, Config] {
  switch (input.combo) {
    case 'ar_height':
      return calcARHeight(input.ar, input.height, cabinetType, cab)
    case 'ar_width':
      return calcARWidth(input.ar, input.width, cabinetType, cab)
    case 'ar_diagonal':
      return calcARDiagonal(input.ar, input.diagonal, cabinetType, cab)
    case 'height_width':
      return calcHeightWidth(input.height, input.width, cabinetType, cab)
    case 'height_diagonal':
      return calcHeightDiagonal(input.height, input.diagonal, cabinetType, cab)
    case 'width_diagonal':
      return calcWidthDiagonal(input.width, input.diagonal, cabinetType, cab)
  }
}

// --- Public API ---

export function calculate(input: CalcInput): Config[] {
  const results: Config[] = []

  for (const cabinetType of CABINET_TYPES) {
    const cab = CABINETS[cabinetType]
    const [lower, upper] = calculateForCabinet(input, cabinetType, cab)
    results.push(lower, upper)
  }

  return results  // [16:9 lower, 16:9 upper, 1:1 lower, 1:1 upper]
}
```

### Best Practices
- **Exhaustive switch**: TypeScript enforces all 6 combos are handled. If we add a 7th combo to `CalcInput`, the compiler errors until we add a case.
- **`floorCeil` helper**: centralizes the exact-match logic (if floor === ceil, upper = floor + 1). Written once, used in every combo.
- **`buildConfig` helper**: single place where width/height/diagonal/AR are derived from (rows, cols). No duplication, no chance of computing diagonal differently in two places.
- **All inputs in mm**: the function signature takes mm. Conversion happens outside this file.
- **No React imports**: this file is portable to Node, a worker, or a server.
- **Return order is fixed**: `[16:9 lower, 16:9 upper, 1:1 lower, 1:1 upper]` — index 0-3, matching the 4 columns in the results table. Document this in a comment.

### Validation
- [x] File compiles with zero errors
- [x] No `any` types, no `as` casts
- [x] Tested in Step 7

---

## Step 7: Calculation Engine Tests — `src/lib/calculate.test.ts`

### File Created
`src/lib/calculate.test.ts`

### Test Cases

These are the **verified test cases from the PRD** (section 9), plus edge cases.

```ts
import { describe, it, expect } from 'vitest'
import { calculate } from './calculate'
import { toMM } from './units'

// Helper: find config by cabinet type and position
function getConfig(results: Config[], cabinetType: string, position: 'lower' | 'upper') {
  const index = cabinetType === '16:9'
    ? (position === 'lower' ? 0 : 1)
    : (position === 'lower' ? 2 : 3)
  return results[index]!
}

describe('calculate', () => {

  // --- PRD Test Case 1: AR 16:9 + Height 100" — 16:9 cabinet ---
  describe('AR 16:9 + Height 100 inches', () => {
    const results = calculate({
      combo: 'ar_height',
      ar: 16 / 9,
      height: toMM(100, 'in'),
    })

    it('returns 4 results', () => {
      expect(results).toHaveLength(4)
    })

    it('16:9 lower: 7x7', () => {
      const c = getConfig(results, '16:9', 'lower')
      expect(c.cols).toBe(7)
      expect(c.rows).toBe(7)
      expect(c.totalCabinets).toBe(49)
      expect(fromMM(c.heightMM, 'in')).toBeCloseTo(93.01, 1)
      expect(c.aspectRatio).toBeCloseTo(1.78, 1)
    })

    it('16:9 upper: 8x8', () => {
      const c = getConfig(results, '16:9', 'upper')
      expect(c.cols).toBe(8)
      expect(c.rows).toBe(8)
      expect(c.totalCabinets).toBe(64)
      expect(fromMM(c.heightMM, 'in')).toBeCloseTo(106.30, 1)
      expect(c.aspectRatio).toBeCloseTo(1.78, 1)
    })

    // --- PRD Test Case 2: same input, 1:1 cabinet ---
    it('1:1 lower: 9x5', () => {
      const c = getConfig(results, '1:1', 'lower')
      expect(c.cols).toBe(9)
      expect(c.rows).toBe(5)
      expect(fromMM(c.heightMM, 'in')).toBeCloseTo(98.43, 1)
      expect(c.aspectRatio).toBeCloseTo(1.8, 1)
    })

    it('1:1 upper: 11x6', () => {
      const c = getConfig(results, '1:1', 'upper')
      expect(c.cols).toBe(11)
      expect(c.rows).toBe(6)
      expect(fromMM(c.heightMM, 'in')).toBeCloseTo(118.11, 1)
      expect(c.aspectRatio).toBeCloseTo(1.83, 1)
    })
  })

  // --- PRD Test Case 3: Width 100" + Diagonal 200" — 16:9 cabinet ---
  describe('Width 100" + Diagonal 200"', () => {
    const results = calculate({
      combo: 'width_diagonal',
      width: toMM(100, 'in'),
      diagonal: toMM(200, 'in'),
    })

    it('16:9 lower: 4x13', () => {
      const c = getConfig(results, '16:9', 'lower')
      expect(c.cols).toBe(4)
      expect(c.rows).toBe(13)
      expect(fromMM(c.widthMM, 'in')).toBeCloseTo(94.49, 1)
      expect(fromMM(c.diagonalMM, 'in')).toBeCloseTo(196.89, 0)
    })

    it('16:9 upper: 5x14', () => {
      const c = getConfig(results, '16:9', 'upper')
      expect(c.cols).toBe(5)
      expect(c.rows).toBe(14)
    })
  })

  // --- Edge cases ---
  describe('edge cases', () => {

    it('exact match: floor === ceil, upper is +1', () => {
      // 16:9 cab height = 337.5mm. 5 rows = 1687.5mm exactly.
      const results = calculate({
        combo: 'ar_height',
        ar: 16 / 9,
        height: 337.5 * 5,  // exactly 5 rows
      })
      const lower = getConfig(results, '16:9', 'lower')
      const upper = getConfig(results, '16:9', 'upper')
      expect(lower.rows).toBe(5)
      expect(upper.rows).toBe(6)
    })

    it('very small input: clamps to minimum 1x1', () => {
      const results = calculate({
        combo: 'height_width',
        height: 1,  // 1mm
        width: 1,   // 1mm
      })
      const lower = getConfig(results, '16:9', 'lower')
      expect(lower.rows).toBeGreaterThanOrEqual(1)
      expect(lower.cols).toBeGreaterThanOrEqual(1)
    })

    it('AR + Width combo works', () => {
      const results = calculate({
        combo: 'ar_width',
        ar: 16 / 9,
        width: toMM(100, 'in'),
      })
      expect(results).toHaveLength(4)
      // Just verify it runs and returns sensible numbers
      for (const c of results) {
        expect(c.rows).toBeGreaterThanOrEqual(1)
        expect(c.cols).toBeGreaterThanOrEqual(1)
        expect(c.aspectRatio).toBeGreaterThan(0)
      }
    })

    it('AR + Diagonal combo works', () => {
      const results = calculate({
        combo: 'ar_diagonal',
        ar: 16 / 9,
        diagonal: toMM(200, 'in'),
      })
      expect(results).toHaveLength(4)
    })

    it('Height + Width combo works', () => {
      const results = calculate({
        combo: 'height_width',
        height: toMM(100, 'in'),
        width: toMM(200, 'in'),
      })
      expect(results).toHaveLength(4)
    })

    it('Height + Diagonal combo works', () => {
      const results = calculate({
        combo: 'height_diagonal',
        height: toMM(100, 'in'),
        diagonal: toMM(200, 'in'),
      })
      expect(results).toHaveLength(4)
    })
  })
})
```

### Best Practices
- Test the **exact values from the Loom video** — these are our acceptance criteria.
- Use `toBeCloseTo` with explicit decimal precision — `toBeCloseTo(93.01, 1)` means correct to 1 decimal place.
- Test all 6 combos, even if just a smoke test ("returns 4 results, all positive").
- Test the exact-match edge case explicitly.
- Import `toMM`/`fromMM` in tests to convert — mirrors how the app will use the engine.

### Validation
- [x] `npm test` — **ALL tests pass**
- [x] PRD test cases 1, 2, 3 produce exact expected values
- [x] Exact match edge case: lower gets the exact, upper gets +1
- [x] Minimum 1x1 clamp works
- [x] All 6 combos return 4 results each

---

## Step 8: Nearest Size Scoring — `src/lib/nearest.ts`

### File Created
`src/lib/nearest.ts`

### Content

```ts
import type { CalcInput, Config } from './types'

/**
 * Returns the index (0-3) of the config that is the closest
 * overall match to the user's input.
 *
 * Scoring: sum of normalized errors for each locked parameter.
 * Lower score = closer match.
 */
export function findNearestIndex(
  results: Config[],
  input: CalcInput
): number {
  let bestIndex = 0
  let bestScore = Infinity

  for (let i = 0; i < results.length; i++) {
    const config = results[i]!
    let score = 0

    switch (input.combo) {
      case 'ar_height':
        score += Math.abs(config.heightMM - input.height) / input.height
        score += Math.abs(config.aspectRatio - input.ar) / input.ar
        break
      case 'ar_width':
        score += Math.abs(config.widthMM - input.width) / input.width
        score += Math.abs(config.aspectRatio - input.ar) / input.ar
        break
      case 'ar_diagonal':
        score += Math.abs(config.diagonalMM - input.diagonal) / input.diagonal
        score += Math.abs(config.aspectRatio - input.ar) / input.ar
        break
      case 'height_width':
        score += Math.abs(config.heightMM - input.height) / input.height
        score += Math.abs(config.widthMM - input.width) / input.width
        break
      case 'height_diagonal':
        score += Math.abs(config.heightMM - input.height) / input.height
        score += Math.abs(config.diagonalMM - input.diagonal) / input.diagonal
        break
      case 'width_diagonal':
        score += Math.abs(config.widthMM - input.width) / input.width
        score += Math.abs(config.diagonalMM - input.diagonal) / input.diagonal
        break
    }

    if (score < bestScore) {
      bestScore = score
      bestIndex = i
    }
  }

  return bestIndex
}
```

### Best Practices
- Exhaustive switch — every combo scored on exactly the parameters the user locked.
- Normalized errors (divide by target) so height error and AR error are weighted equally regardless of scale.
- Returns an index, not a Config — keeps the results array as the single source of truth.

### Validation
- [x] File compiles
- [x] For PRD test case 1 (AR 16:9 + H 100"), `findNearestIndex` returns `2` (index of 9×5 1:1 lower) — matches the reference app screenshot
- [x] Add a quick test in `calculate.test.ts` or a new `nearest.test.ts` to verify

---

## Step 9: Final Phase 1 Verification

Run the full suite and verify everything:

```bash
npm run build        # zero errors, zero warnings
npm test             # all tests pass
npx tsc --noEmit     # type check passes
```

### Checklist
- [x] `src/lib/types.ts` — all types defined, no `any`
- [x] `src/lib/config.ts` — cabinet dims, AR presets, unit multipliers
- [x] `src/lib/units.ts` — toMM/fromMM, 2 functions
- [x] `src/lib/units.test.ts` — all conversion tests pass
- [x] `src/lib/calculate.ts` — all 6 combos implemented
- [x] `src/lib/calculate.test.ts` — PRD test cases 1-3 pass, edge cases pass
- [x] `src/lib/nearest.ts` — scoring logic, returns correct index
- [x] `npm run build` — clean
- [x] `npx tsc --noEmit` — clean
- [x] `npm test` — all green

### Files Created in Phase 1

```
src/
  lib/
    types.ts
    config.ts
    units.ts
    units.test.ts
    calculate.ts
    calculate.test.ts
    nearest.ts
```

**Total: 7 files.** Zero UI. Every number the app will ever produce is now correct and proven.

---

## Phase 1 → Phase 2 Handoff

Phase 1 delivers:
- A tested, type-safe calculation engine that takes `CalcInput` (in mm) and returns `Config[]`
- A scoring function that identifies the nearest match
- A config layer that can be extended with new cabinet types / AR presets without touching logic

Phase 2 picks up from here with:
- `reducer.ts` — wiring the calc engine into state transitions
- `ParameterForm.tsx` — the lock-based input UI
- Unit switching in the UI layer via `fromMM`
